<!doctype html><meta charset=utf-8><title>Room 1</title>
<style>
  body{margin:0}
  #c{position:absolute;width:100%;height:100%}
  #msgNode,#infoNode{color:white;font-family:monospace}
  #msgNode{position:absolute;width:100%;bottom:50%;font-size:2em;text-align:center}
  #infoNode{position:absolute;bottom:0;left:0}
</style>
<canvas id=c></canvas>
<p id=msgNode></p>
<div id=infoNode></div>
<script>
var c = document.getElementById('c');
var width = c.width = document.documentElement.clientWidth;
var height = c.height = document.documentElement.clientHeight;
var ctx = c.getContext('2d');
ctx.fillStyle = 'black';
ctx.fillRect(0, 0, width, height);

// g is a Ground.
var genRooms = function(g) {
  g.a = new Uint8Array(g.w * g.h);
  var nr = (g.w >> 3) * (g.h >> 3); // number of rooms.
  var rooms = [g.room(g.prot.x, g.prot.y, 4, 4)];
  for (var i = 0; i < nr - 1; i++) { 
    rooms.push(g.randRoom());
  }
  var allRooms = rooms.slice();
  var r = rooms[0];
  for (;rooms.length > 0;) {
    var ci = r.closest(rooms); // closest room index.
    var closest = rooms[ci];
    rooms.splice(ci, 1);
    g.passage(r.cx, r.cy, closest.cx, closest.cy);
    r = closest;
  }
  for (var i = 0; i < nr/4; i++) g.corridor();
  return allRooms;
};

// g is a Ground.
var paint = function(ctx, g) {
  g.paint(ctx);
};

var Ground = function() {
  this.bs = 8; // block side.
  this.w = (width / this.bs)>>>0; // array width.
  this.h = (height / this.bs)>>>0; // array height.
  this.tiles = this.w * this.h;
  this.a = new Uint8Array(this.tiles);
  this.noise = new Uint8Array(this.tiles);
  this.genNoise();

  this.entities = new Array(this.tiles);
  for (var i = 0; i < this.tiles; i++) {
    this.entities[i] = [];
  }
  this.prot = new Protagonist(this, 4, 4); // protagonist
  this.prot.life = 2 * (this.w + this.h);
  this.portal = new Entity(this, 0, 0);
  this.diggers = [];
  this.parasites = [];
  this.swarmers = [];
  this.level = 3;
};

Ground.prototype = {
  idx(x, y) { return x + y * this.w; },
  pos(i) { return [i % this.w, (i / this.w) >>> 0]; },
  up(i) { if (i < this.w) { return -1; } else { return i - this.w; } },
  right(i) { if ((i % this.w) === this.w - 1) { return -1; } else { return i + 1; } },
  down(i) { if (i >= this.w * (this.h - 1)) { return -1; } else { return i + this.w; } },
  left(i) { if ((i % this.w) === 0) { return -1; } else { return i - 1; } },
  relPos(pos, dir) {
    switch(dir) {
      case 0: return this.up(pos);
      case 1: return this.right(pos);
      case 2: return this.down(pos);
      default: return this.left(pos);
    }
  },
  rect(x, y, w, h, f) {
    var gw = this.w; // ground width.
    var gh = this.h; // ground height.
    var a = this.a;
    if (x < 0) { x = 0; }
    if (x >= gw) { x = gw - 1; }
    if (y < 0) { y = 0; }
    if (y >= gh) { y = gh - 1; }
    if (w > gw - x) { w = gw - x; }
    if (h > gh - h) { h = gh - h; }

    var idx = x + y * gw;
    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        f(a, idx);
        idx++;
      }
      idx += x + (gw - (x + w));
    }
  },
  // Rectangular border whose top left is at x,y and with width w and height h.
  // f is called with this.a and the index of the border element as parameters.
  // The items are added clockwise from the top left.
  rectBorder(x, y, w, h, f) {
    var gw = this.w; // ground width.
    var gh = this.h; // ground height.
    var a = this.a;
    if (x < 0) { w += x; x = 0; }
    if (x >= gw) { x = gw - 1; }
    if (y < 0) { h += y; y = 0; }
    if (y >= gh) { y = gh - 1; }
    if (w > gw - x) { w = gw - x; }
    if (h > gh - y) { h = gh - y; }

    var idx = x + y * gw;
    // top
    for (var i = 1; i < w; i++, idx++) { f(a, idx); }
    // right
    for (var i = 1; i < h; i++, idx += gw) { f(a, idx); }
    // bottom
    for (var i = 1; i < w; i++, idx--) { f(a, idx); }
    // left
    for (var i = 1; i < h; i++, idx -= gw) { f(a, idx); }
  },
  // Rectangular border whose top left is at x,y and with width w and height h.
  // Returns {top:[], right:[], bottom:[], left:[]} with lists of indices, starting with the diagonal.
  rectSides(x, y, w, h) {
    var gw = this.w; // ground width.
    var gh = this.h; // ground height.
    var a = this.a;
    if (x < 0) { w += x; x = 0; }
    if (x >= gw) { x = gw - 1; }
    if (y < 0) { h += y; y = 0; }
    if (y >= gh) { y = gh - 1; }
    if (w > gw - x) { w = gw - x; }
    if (h > gh - y) { h = gh - y; }
    var top = [], right = [], bottom = [], left = [];

    var idx = x + y * gw;
    // top 
    for (var i = 1; i < w; i++, idx++) { top.push(idx); }
    // right
    for (var i = 1; i < h; i++, idx += gw) { right.push(idx); }
    // bottom
    for (var i = 1; i < w; i++, idx--) { bottom.push(idx); }
    // left
    for (var i = 1; i < h; i++, idx -= gw) { left.push(idx); }
    return {top:top, right:right, bottom:bottom, left:left};
  },
  room(cx, cy, w, h) {
    var px = cx - (w >> 1);
    var py = cy - (h >> 1);
    this.rect(px, py, w, h, function(a, i) {a[i] = 1});
    return new Room(px, py, w, h, cx, cy);
  },
  randRoom() {
    var cx = (Math.random() * this.w)>>0;
    var cy = (Math.random() * this.h)>>0;
    var w = ((Math.random() * 4)>>0) + 2;
    var h = ((Math.random() * 4)>>0) + 2;
    return this.room(cx, cy, w, h);
  },
  corridor() {
    var gw = this.w; // ground width.
    var gh = this.h; // ground height.
    var a = this.a;
    var x = (Math.random() * gw)>>0;
    var y = (Math.random() * gh)>>0;
    var dir = 0;
    for (var i = 0; i < 16; i++) {
      a[x + y * gw] = 1;
      if (i % 2 === 0) { // don't change twice in a row.
        var chdir = (Math.random() * 6)>>0;
        if (chdir == 0) { dir++; }
        if (chdir == 1) { dir--; }
        if (dir > 3) { dir = 0; }
        if (dir < 0) { dir = 3; }
      }
      if (dir === 0) { x++; }
      else if (dir === 1) { y++; }
      else if (dir === 2) { x--; }
      else if (dir === 3) { y--; }
      
      if (x < 0 || x >= gw || y < 0 || y >= gh) { break; }
    }
  },
  // rx, ry: position relative to x, y.
  relative(x, y, rx, ry) {
    var a = this.a, gw = this.w, gh = this.h;
    if (rx < 0 && x < -rx) { rx = -x; }
    if (rx > 0 && x + rx > gw) { rx = gw - x; }
    if (ry < 0 && y < -ry) { ry = -y; }
    if (ry > 0 && y + ry > gh) { ry = gh - y; }
    var init = x + y * gw;
    return init + rx + gw * ry;
  },
  horiz(x, y, w, f) {
    var a = this.a, gw = this.w;
    if (w < 0 && x < -w) { w = -x; }
    if (w > 0 && x + w > gw) { w = gw - x; }
    // put x on the left of the line.
    if (w < 0) { x += w; w = 1 - w; }
    var init = x + y * gw;
    var re = init + w; // right edge.
    for (var i = init; i < re; i++) { f(a, i); }
  },
  vert(x, y, h, f) {
    var a = this.a;
    var gw = this.w;
    var gh = this.h;
    if (h < 0 && y < -h) { h = -y; }
    if (h > 0 && y + h > gh) { h = gh - y; }
    // put y on the top of the line.
    if (h < 0) { y += h; h = -h; }
    var init = x + y * gw;
    var be = init + gw * h; // bottom edge.
    for (var i = init; i < be; i += gw) { f(a, i); }
  },
  passage(x1, y1, x2, y2) {
    var hf = (Math.random() * 2)>>0 === 0; // horizontal first.
    if (false) {
      this.horiz(x1, y1, x2 - x1, function(a, i) {a[i] = 1});
      this.vert(x2, y1, y2 - y1, function(a, i) {a[i] = 1});
    } else {
      this.vert(x1, y1, y2 - y1, function(a, i) {a[i] = 1});
      this.horiz(x1, y2, x2 - x1, function(a, i) {a[i] = 1});
    }
  },
  genNoise() {
    var a = this.a, l = a.length;
    for (var i = 0; i < l; i++) {
      this.noise[i] = randBlack();
    }
  },
  isWall(idx) {
    return this.a[idx] === 0;
  },
  isOutside(idx) {
    var pos = this.pos(idx);
    return pos[0] < 0 || pos[0] >= this.w || pos[1] < 0 || pos[1] >= this.h;
  },
  isBlocked(idx) { return this.isWall(idx) || this.isOutside(idx); },
  // List of entities at board index `pos`.
  entitiesAt(pos) {
    return this.entities[pos];
  },
  removeEntity(pos, entity) {
    var index = this.entities[pos].indexOf(entity);
    this.entities[pos].splice(index, 1);
  },
  addEntity(pos, entity) {
    this.entities[pos].push(entity);
  },
  checkGhosts() {
    for (var i = 0; i < this.entities.length; i++) {
      for (var j = 0; j < this.entities[i].length; j++) {
        var entity = this.entities[i][j];
        if (!this.diggers.includes(entity)
            && !this.parasites.includes(entity)
            && !this.swarmers.includes(entity)
            && entity !== this.prot
            && entity !== this.portal) {
          debugger
        }
      }
    }
  },
  killEntity(entity) {
    this.removeEntity(entity.idx(), entity);
    if (entity instanceof Digger) {
      this.diggers.splice(this.diggers.indexOf(entity), 1);
    } else if (entity instanceof Parasite) {
      this.parasites.splice(this.parasites.indexOf(entity), 1);
    } else if (entity instanceof Swarmer) {
      this.swarmers.splice(this.swarmers.indexOf(entity), 1);
    }
    //this.checkGhosts();
  },
  moveEntities() {
    for (var i = 0; i < this.diggers.length; i++) {
      this.diggers[i].move();
    }
    for (var i = 0; i < this.parasites.length; i++) {
      this.parasites[i].move();
    }
    for (var i = 0; i < this.swarmers.length; i++) {
      this.swarmers[i].move();
    }
  },
};

var Room = function(px, py, w, h, cx, cy) {
  this.px = px;
  this.py = py;
  this.w = w;
  this.h = h;
  this.cx = cx;
  this.cy = cy;
};

Room.prototype = {
  distance(room) {
    return rectDistance(room.cx, room.cy, this.cx, this.cy);
  },
  closest(rooms) {
    var l = rooms.length;
    var ci; // closest room.
    var cd = 1e10; // closest distance.
    for (var i = 0; i < l; i++) {
      var r = rooms[i];
      var dist = this.distance(r);
      if (dist < cd && dist !== 0) {
        cd = dist;
        ci = i;
      }
    }
    return ci;
  },
  farthest(rooms) {
    var l = rooms.length;
    var fi; // farthest room.
    var fd = 0; // farthest distance.
    for (var i = 0; i < l; i++) {
      var r = rooms[i];
      var dist = this.distance(r);
      if (dist > fd) {
        fd = dist;
        fi = i;
      }
    }
    return fi;
  }
};

var rectDistance = function(ax, ay, bx, by) {
  return Math.abs(ay - by) + Math.abs(ax - bx);
};

var randBlack = function() {
  return (Math.random() * 32)>>0;
};
var randWhite = function() {
  return 64 + ((Math.random() * 32)>>0);
};

var Entity = function(g, x, y) {
  this.g = g;
  this.x = x;
  this.y = y;
  this.life = 1;
  this.color = [255, 165, 0, 255];
  this.g.addEntity(this.idx(), this);
};
Entity.prototype = {
  placeAt(x, y) {
    this.g.removeEntity(this.idx(), this);
    this.x = x; this.y = y;
    this.g.addEntity(this.idx(), this);
  },
  idx() {return this.g.idx(this.x, this.y);},
  goUp() {
    var idx = this.idx();
    var pos = this.g.up(idx);
    if (!this.g.isWall(this.g.up(idx)) && this.y > 0 && this.life > 0) {
      this.g.removeEntity(this.idx(), this);
      this.y--;
      if (this.y < 0) {y = this.g.h;}
      this.life--;
      if (!this.isDead()) {this.g.addEntity(pos, this);}
      return true;
    }
    return false;
  },
  goRight() {
    var idx = this.idx();
    var pos = this.g.right(idx);
    if (!this.g.isWall(this.g.right(idx)) && this.x < this.g.w - 1 && this.life > 0) {
      this.g.removeEntity(this.idx(), this);
      this.x++;
      this.life--;
      if (!this.isDead()) {this.g.addEntity(pos, this);}
      return true;
    }
    return false;
  },
  goDown() {
    var idx = this.idx();
    var pos = this.g.down(idx);
    if (!this.g.isWall(this.g.down(idx)) && this.y < this.g.h - 1 && this.life > 0) {
      this.g.removeEntity(this.idx(), this);
      this.y++;
      this.life--;
      if (!this.isDead()) {this.g.addEntity(pos, this);}
      return true;
    }
    return false;
  },
  goLeft() {
    var idx = this.idx();
    var pos = this.g.left(idx);
    if (!this.g.isWall(this.g.left(idx)) && this.x > 0 && this.life > 0) {
      this.g.removeEntity(this.idx(), this);
      this.x--;
      this.life--;
      if (!this.isDead()) {this.g.addEntity(pos, this);}
      return true;
    }
    return false;
  },
  go(direction) {
    if (direction === 0) {return this.goUp();}
    else if (direction === 1) {return this.goRight();}
    else if (direction === 2) {return this.goDown();}
    else {return this.goLeft();}
  },
  isDead() {return this.life <= 0;},
  interact(entity) {},
  move() {},
  vision() {return this.g.vision(this.x, this.y);},
  visionEntities(vision) {
    var entities = [];
    for (var i = 0; i < vision.length; i++) {
      entities = entities.concat(this.g.entitiesAt(vision[i]));
    }
    return entities;
  },
  // List of directions (0 = top, 1 = right, etc.)
  awayFrom(x, y) {
    var dx = x - this.x;
    var dy = y - this.y;
    if (dx === 0) {
      if (dy === 0) {return [0, 1, 2, 3];}
      else if (dy > 0) {return [0];}
      else {return [2];}
    } else if (dx > 0) {
      if (dy === 0) {return [3];}
      else if (dy > 0) {return [0, 3];}
      else {return [2, 3];}
    } else {
      if (dy === 0) {return [1];}
      else if (dy > 0) {return [0, 1];}
      else {return [2, 1];}
    }
  },
  towards(x, y) {
    var dx = x - this.x;
    var dy = y - this.y;
    if (dx === 0) {
      if (dy === 0) {return [];}
      else if (dy > 0) {return [2];}
      else {return [0];}
    } else if (dx > 0) {
      if (dy === 0) {return [1];}
      else if (dy > 0) {return [1, 2];}
      else {return [0, 1];}
    } else {
      if (dy === 0) {return [3];}
      else if (dy > 0) {return [2, 3];}
      else {return [0, 3];}
    }
  },
};

var Protagonist = function(g, x, y) {
  Entity.call(this, g, x, y);
  this.color = [100, 149, 237, 255];
};
Protagonist.prototype = Object.create(Entity.prototype);
Protagonist.prototype.constructor = Protagonist;
Protagonist.prototype.interact = function(entity) {
  if (entity instanceof Digger) {
    if (entity.egg <= 0) {
      entity.life -= 100;
      if (entity.isDead()) {
        this.g.killEntity(entity);
        this.life += 100;
      }
    } else {this.g.killEntity(entity);}
  }
};

var Digger = function(g, x, y) {
  Entity.call(this, g, x, y);
  this.color = [218, 112, 214, 255];
  this.life = 500;
  this.direction = (4 * Math.random()) >>> 0;
  this.egg = 0;
  this.fullStomach = 42;
  this.stomach = this.fullStomach;
};
Digger.prototype = Object.create(Entity.prototype);
Digger.prototype.constructor = Digger;
Digger.prototype.interact = function(entity) {
  if ((entity instanceof Digger) && (entity.egg <= 0) && (this.stomach > 0)) {
    var idx = this.idx();
    var diggers = 0;
    var entities = this.visionEntities(this.vision());
    for (var i = 0; i < entities.length; i++) {
      if (entities[i] instanceof Digger) { diggers++; }
    }
    if (diggers < 3) {  // Three is a crowd.
      this.stomach--;
      var child = new Digger(this.g, this.x, this.y);
      child.egg = 100;
      child.color = [186, 85, 211, 255];
      child.stomach = entity.stomach;
      this.g.diggers.push(child);
    }
  } else if (entity instanceof SwarmerLarva) {
    entity.life -= 50;
    this.stomach = this.fullStomach;
    if (entity.isDead()) {
      this.g.killEntity(entity);
    }
  }
  this.life -= 2;
  if (this.isDead()) {this.g.killEntity(this); return;}
};
Digger.prototype.move = function() {
  if (this.isDead()) {this.g.killEntity(this); return;}
  if (this.egg > 0) {
    this.egg--;
    if (this.egg <= 0) {
      this.color = [218, 112, 214, 255];
    }
    return false;
  }
  var vision = this.vision();
  var entities = this.visionEntities(vision);
  for (var i = 0; i < entities.length; i++) {
    var entity = entities[i];
    if (entity instanceof Protagonist) {
      // Get away from the predator.
      this.direction = pick(this.awayFrom(entity.x, entity.y));
      this.go(this.direction);
      return true;
    }
  }
  var hasMoved = false;
  if (this.direction === 0) {hasMoved = this.goUp();}
  else if (this.direction === 1) {hasMoved = this.goRight();}
  else if (this.direction === 2) {hasMoved = this.goDown();}
  else if (this.direction === 3) {hasMoved = this.goLeft();}
  if (!hasMoved) {
    if (Math.random() < 0.5) {this.direction++;}
    else {this.direction--;}
    if (this.direction < 0) {this.direction += 4;}
    else if (this.direction > 3) {this.direction -= 4;}
  }
  return hasMoved;
};
// Digging.
Digger.prototype.walls = function() {
  // Number of walls around the digger.
  var walls = 0;
  var idx = this.idx();
  if (this.g.isWall(this.g.up(idx))) {walls++;}
  if (this.g.isWall(this.g.right(idx))) {walls++;}
  if (this.g.isWall(this.g.down(idx))) {walls++;}
  if (this.g.isWall(this.g.left(idx))) {walls++;}
  return walls;
}
Digger.prototype.goUp = function() {
  if (!Entity.prototype.goUp.call(this)) {
    var up = this.g.up(this.idx());
    var walls = this.walls();
    var rand = Math.random();
    if (this.g.isWall(up) && ((walls > 2 && rand < 0.8) || (walls === 2 && this.life < 5 && rand < 0.01))) {this.g.a[up] = 1;}
    return false;
  }
  return true;
};
Digger.prototype.goRight = function() {
  if (!Entity.prototype.goRight.call(this)) {
    var right = this.g.right(this.idx());
    var walls = this.walls();
    var rand = Math.random();
    if (this.g.isWall(right) && ((walls > 2 && rand < 0.8) || (walls === 2 && this.life < 5 && rand < 0.01))) {this.g.a[right] = 1;}
    return false;
  }
  return true;
};
Digger.prototype.goDown = function() {
  if (!Entity.prototype.goDown.call(this)) {
    var down = this.g.down(this.idx());
    var walls = this.walls();
    var rand = Math.random();
    if (this.g.isWall(down) && ((walls > 2 && rand < 0.8) || (walls === 2 && this.life < 5 && rand < 0.01))) {this.g.a[down] = 1;}
    return false;
  }
  return true;
};
Digger.prototype.goLeft = function() {
  if (!Entity.prototype.goLeft.call(this)) {
    var left = this.g.left(this.idx());
    var walls = this.walls();
    var rand = Math.random();
    if (this.g.isWall(left) && ((walls > 2 && rand < 0.8) || (walls === 2 && this.life < 5 && rand < 0.01))) {this.g.a[left] = 1;}
    return false;
  }
  return true;
};

var Parasite = function(g, x, y) {
  Entity.call(this, g, x, y);
  this.color = [255, 63, 0, 255];
  this.life = 5 * (this.g.w + this.g.h);
  this.path = [];
  this.dx = 0, this.dy = 0, this.maxFollow = 2, this.follow = 0;
  this.maxSwitchTarget = 4, this.switchTarget = ((Math.random() * this.maxSwitchTarget) >>> 0);
  this.pickTarget();
  this.waitTime = 7, this.wakeTime = 7, this.wake = ((Math.random() * this.wakeTime) >>> 0);
};
Parasite.prototype = Object.create(Entity.prototype);
Parasite.prototype.constructor = Parasite;
Parasite.prototype.interact = function(entity) {
  if (this.entityIsFood(entity)) {
    entity.life -= 100;
    if (entity.isDead()) {
      this.g.killEntity(entity);
      this.life += 50;
    }
    if (this.isDead()) {this.g.killEntity(this); return;}
  } else if (this.entityIsInfectable(entity)) {
    entity.infect();
  }
};
Parasite.prototype.entityIsFood = function(entity) {
  return (entity instanceof Protagonist) || ((entity instanceof Digger) && entity.egg > 0);
};
Parasite.prototype.entityIsHarmful = function(entity) {
  return (entity instanceof SwarmerQueen || entity instanceof SwarmerSoldier);
}
Parasite.prototype.entityIsInfectable = function(entity) {
  return (entity instanceof SwarmerLarva) && !entity.infected;
};
Parasite.prototype.pickTarget = function() {
  if (this.switchTarget === 0) {
    this.targetx = this.g.portal.x;
    this.targety = this.g.portal.y;
  } else if (this.switchTarget === 2) {
    this.targetx = ((Math.random() * this.g.w) >>> 0);
    this.targety = ((Math.random() * this.g.h) >>> 0);
  } else {
    this.targetx = this.g.prot.x;
    this.targety = this.g.prot.y;
  }
  this.switchTarget++;
  this.switchTarget %= this.maxSwitchTarget;
};
Parasite.prototype.move = function() {
  var self = this;
  if (this.isDead()) {this.g.killEntity(this); return;}

  var vision = this.vision();
  var entities = this.visionEntities(vision);
  for (var i = 0; i < entities.length; i++) {
    var entity = entities[i];
    if (this.entityIsFood(entity) || this.entityIsInfectable(entity)) {
      // Get to our prey.
      this.targetx = entity.x; this.targety = entity.y;
      this.dx = entity.x - this.x; this.dy = entity.y - this.y;
      this.follow = this.maxFollow;
      this.path = [];
      this.direction = pick(this.towards(entity.x, entity.y));
      return this.go(this.direction);
    } else if (this.entityIsHarmful(entity)) {
      return this.go(pick(this.awayFrom(entity.x, entity.y)));
    }
  }

  this.wake--;
  if (this.wake < -this.waitTime) {
    this.wake = this.wakeTime + ((Math.random() * 4) >>> 0);
  } else if (this.wake < 0) {
    return false;
  }
  if (this.path.length === 0) {
    if (this.follow > 0) {
      this.follow--;
      this.path = this.g.bestFirstSearch(this.idx(),
        function heuristic(idx) {
          var pos = self.g.pos(idx), posx = pos[0], posy = pos[1];
          var sameDir = (posx - self.x) * self.dx + (posy - self.y) * self.dy;  // scalar product
          return sameDir;
        },
        50);
      return false;

    } else {
      this.pickTarget();
      this.path = this.g.path(this.idx(), this.g.idx(this.targetx, this.targety));
      return false;
    }
  }
  var success = this.go(this.path.shift());
  if (!success) {
    this.path = [];
  }
  return success;
};

var SwarmerScent;
var Swarmer = function(g, x, y) {
  Entity.call(this, g, x, y);
  this.life = 500;
  this.role = SwarmerSoldier;
  this.queen = this;
  this.hugWall = Math.floor(Math.random() * 2); // 0=left, 1=right
  this.wallDir = Math.floor(Math.random() * 4); // Where the wall should be.
};
Swarmer.prototype = Object.create(Entity.prototype);
Swarmer.prototype.constructor = Swarmer;
Swarmer.prototype.rotateDir = function(dir, wiseness) {
  // wiseness: 1 is clockwise, -1 is counterclockwise.
  var newDir = dir + wiseness;
  if (newDir < 0) { newDir = 3; }
  else if (newDir > 3) { newDir = 0; }
  return newDir;
};
Swarmer.prototype.isNuisance = function(entity) {
  return !((entity instanceof Swarmer) || (entity instanceof Digger));
};
Swarmer.prototype.interact = function(entity) {
  if (this.isNuisance(entity)) {
    entity.life -= 10;
    if (entity.isDead()) {
      this.g.killEntity(entity);
    }
  }
};
Swarmer.prototype.move = function() {
  if (this.isDead()) {this.g.killEntity(this); return;}
  var idx = this.idx();
  var wallPos = this.g.relPos(idx, this.wallDir);
  var prevWallPos = this.g.relPos(wallPos, this.rotateDir(this.wallDir, -1));

  var success = false;
  if (this.g.isBlocked(wallPos)) {
    if ((this instanceof SwarmerLarva) && Math.random() < 0.05) {
      this.wallDir = Math.floor(Math.random() * 4);
    }
    var dir = this.rotateDir(this.wallDir, 1);
    success = this.go(dir);
    if (!success) {
      this.wallDir = this.rotateDir(this.wallDir, 1);
    }
  } else if (this.g.isBlocked(prevWallPos)) {
    success = this.go(this.wallDir);
    this.wallDir = this.rotateDir(this.wallDir, -1);
  } else {
    success = this.go(this.wallDir);
  }
  return success;
};

var SwarmerLarva = function(g, x, y) {
  Swarmer.call(this, g, x, y);
  this.color = [170, 170, 119, 255];
  this.growth = 0;
  this.eclosion = 100 + ((Math.random() * (this.life - 100))|0);
  this.wait = 0;
  this.infected = false;
}
SwarmerLarva.prototype = Object.create(Swarmer.prototype);
SwarmerLarva.prototype.constructor = SwarmerLarva;
SwarmerLarva.prototype.move = function() {
  if (this.isDead()) {this.g.killEntity(this); return;}
  this.growth++;
  if (this.growth > this.eclosion) {
    if (this.infected) {
      var child = new Parasite(this.g, this.x, this.y);
      this.g.parasites.push(child);
    } else {
      var Role = this.role;
      var child = new Role(this.g, this.x, this.y);
      if (!(child instanceof SwarmerQueen)) {
        child.queen = this.queen;
      }
      this.g.swarmers.push(child);
    }
    this.g.killEntity(this);
    return;
  }
  this.wait++;
  if (this.wait > 1) {
    Swarmer.prototype.move.call(this);
    this.wait = 0;
  }
};
SwarmerLarva.prototype.infect = function() {
  this.infected = true;
  this.color = [204, 170, 119, 255];
  this.growth = 0;
};

var SwarmerQueen = function(g, x, y) {
  Swarmer.call(this, g, x, y);
  this.color = [153, 204, 85, 255];
  this.life = 1000;
  this.gestationBase = 20;
  this.gestation = this.resetGestation();
  this.gestationCount = 0;
}
SwarmerQueen.prototype = Object.create(Swarmer.prototype);
SwarmerQueen.prototype.constructor = SwarmerQueen;
SwarmerQueen.prototype.resetGestation = function() {
  return this.gestationBase + (Math.random() * this.gestationBase)|0;
};
SwarmerQueen.prototype.move = function() {
  if (this.isDead()) {this.g.killEntity(this); return;}

  var vision = this.vision();
  var entities = this.visionEntities(vision);
  var swarmersInSight = 0;
  for (var i = 0; i < entities.length; i++) {
    var entity = entities[i];
    if (this.isNuisance(entity)) {
      // Go threaten the nuisance.
      return this.go(pick(this.towards(entity.x, entity.y)));
    }
    if (entity instanceof Swarmer) { swarmersInSight++; }
  }

  this.gestation--;
  if (this.gestation < 0 && swarmersInSight < 5) {
    this.gestationCount++;
    var child = new SwarmerLarva(this.g, this.x, this.y);
    child.queen = this;
    child.role = (this.gestationCount % 16 === 0)? SwarmerQueen: SwarmerSoldier;
    if (child.role === SwarmerQueen) {child.life *= 2; child.eclosion *= 2;}
    this.g.swarmers.push(child);
    this.gestationBase++;
    this.gestation = this.resetGestation();
    this.life--;
    if (this.isDead()) {this.g.killEntity(this); return}
  }
};
SwarmerQueen.prototype.interact = function(entity) {
  if (this.isNuisance(entity)) {
    entity.life -= 50;
    if (entity.isDead()) {
      this.g.killEntity(entity);
    }
  }
};

var SwarmerSoldier = function(g, x, y) {
  Swarmer.call(this, g, x, y);
  this.color = [187, 170, 102, 255];
}
SwarmerSoldier.prototype = Object.create(Swarmer.prototype);
SwarmerSoldier.prototype.constructor = SwarmerSoldier;
SwarmerSoldier.prototype.interact = function(entity) {
  if (this.isNuisance(entity)
      || (entity instanceof Swarmer) && entity.queen !== this.queen) {
    if (entity instanceof Parasite) {
      entity.life = 0;
    } else {
      entity.life -= 50;
    }
    if (entity.isDead()) {
      this.g.killEntity(entity);
      this.g.killEntity(this);
      return;
    }
  }
};

var pick = function(array) {
  return array[(array.length * Math.random()) >>> 0];
};


// AI

// Return the list of tiles you can see, by index.
Ground.prototype.vision = function(x, y, radius) {
  radius = radius || 5;
  var visible = [], border = [], w = 2 * radius + 1, h = w;
  var gw = this.w, gh = this.h, a = this.a;

  // Method: look at square of increasing radius.
  // Diagonal tile is lit if a diagonal one is.
  // Lateral tiles also.
  // Others are lit if diagonal and lateral are lit.
  var visibility = new Set();
  var pos = this.idx(x, y);
  visibility.add(pos);
  // ir: inner radius (radius inside the vision radius).
  for (var ir = 1; ir <= radius; ir++) {
    var diag = 2 * ir + 1;
    var circle = this.rectSides(x - ir, y - ir, diag, diag);
    var sides = [circle.top, circle.right, circle.bottom, circle.left];
    // si: side index
    for (var si = 0; si < 4; si++) {
      var side = sides[si];
      for (var ci = 0, sideLen = side.length; ci < sideLen; ci++) {
        var cp = side[ci]; // circle position
        // If it is a wall, it is not lit.
        if (a[cp] === 0) {continue}
        var cpos = this.pos(cp);
        var px = cpos[0], py = cpos[1];
        var isDiag = (ci === 0) && (Math.abs(px - x) === Math.abs(py - y));
        var isTop = py < y, isRight = px > x, isBottom = py > y, isLeft = px < x;
        // not a diagonal
        if (!isDiag) {
          if (si === 0 && isTop) { // top 
            if (!visibility.has(this.down(cp))) {continue}
          } else if (si === 1 && isRight) { // right
            if (!visibility.has(this.left(cp))) {continue}
          } else if (si === 2 && isBottom) { // bottom
            if (!visibility.has(this.up(cp))) {continue}
          } else if (si === 3 && isLeft) { // left
            if (!visibility.has(this.right(cp))) {continue}
          }
        }
        if (px > x && py < y) { // top right
          if (!visibility.has(this.left(this.down(cp)))) {continue}
        } else if (px > x && py > y) { // bottom right
          if (!visibility.has(this.left(this.up(cp)))) {continue}
        } else if (px < x && py > y) { // bottom left
          if (!visibility.has(this.right(this.up(cp)))) {continue}
        } else if (px < x && py < y) { // top left
          if (!visibility.has(this.right(this.down(cp)))) {continue}
        }
        visibility.add(cp);
      }
    }
  }

  for (var key of visibility) {visible.push(key);}
  return visible;
};

// Return a list of all tiles, each with the index of the next tile to go to.
Ground.prototype.pathsTo = function(idx) {
  var ntiles = this.tiles;
  var nexts = new Int32Array(ntiles);
  var dirs = new Int32Array(ntiles);  // up/right/down/left
  nexts.fill(-1);
  dirs.fill(-1);
  var costs = new Uint32Array(ntiles);
  var maxCost = Math.pow(2, 32) - 1;
  costs.fill(maxCost);
  costs[idx] = 0;
  var toVisit = new Array(); // Ordered by cost ascending.
  toVisit.push(idx);
  while (toVisit.length > 0) {
    var visiting = toVisit.shift();
    var neighbors = [
      this.down(visiting),
      this.left(visiting),
      this.up(visiting),
      this.right(visiting),
    ];
    for (var i = 0; i < 4; i++) {
      var neighbor = neighbors[i];
      if (this.isWall(neighbor)) {
        var cost = maxCost;
      } else {
        var cost = costs[visiting] + 1;
      }
      if (cost < costs[neighbor]) {
        nexts[neighbor] = visiting;
        dirs[neighbor] = i;
        costs[neighbor] = cost;
        // Insert neighbor, maintaining increasing cost.
        var j = findCost(toVisit, cost, costs);
        toVisit.splice(j, 0, neighbor);
      }
    }
  }
  return {nexts: nexts, dirs: dirs};
};
Ground.prototype.path = function(from, to) {
  var paths = this.pathsTo(to), nexts = paths.nexts, dirs = paths.dirs;
  if (nexts[from] === -1) { return []; }
  var path = [];
  var idx = from;
  while (idx !== to) {
    var next = nexts[idx];
    path.push(dirs[idx]);
    idx = next;
  }
  return path;
};
function findCost(toVisit, cost, costs) {
  var lo = 0, hi = toVisit.length;
  while (lo !== hi) {
    var mid = (((hi - lo) / 2)|0) + lo;
    var midCost = costs[toVisit[mid]];
    if (cost === midCost) { return mid; }
    else if (cost < midCost) { hi = mid; }
    else { lo = mid + 1; }
  }
  return lo;
}
Ground.prototype.bestFirstSearch = function(from, heuristic, numIter) {
  var toVisit = [{idx: from, score: 0, dir: undefined}];
  var visited = new Map();  // maps to direction to previous.
  var visitedDir = new Map();  // maps to direction to get there.
  for (var iterations = 0; iterations < numIter && toVisit.length > 0; iterations++) {
    var visiting = toVisit.shift();
    var visitingIdx = visiting.idx;
    visited.set(visitingIdx, visiting.prev);
    visitedDir.set(visitingIdx, visiting.dir);
    var neighbors = [
      this.up(visitingIdx),
      this.right(visitingIdx),
      this.down(visitingIdx),
      this.left(visitingIdx),
    ];
    for (var i = 0; i < 4; i++) {
      var neighbor = neighbors[i];
      if (!this.isWall(neighbor) && !visited.has(neighbor)) {
        var score = heuristic(neighbor);
        // Insert neighbor, maintaining decreasing score.
        var j = findScore(toVisit, score);
        toVisit.splice(j, 0, {idx: neighbor, score: score, prev: visitingIdx, dir: i});
      }
    }
  }
  var path = [];
  var cur = visitingIdx;
  while (cur !== from) {
    path.push(visitedDir.get(cur));
    cur = visited.get(cur);
  }
  path.reverse();
  return path;
}

function findScore(list, score) {
  var lo = 0, hi = list.length;
  while (lo !== hi) {
    var mid = (((hi - lo) / 2)|0) + lo;
    var midScore = list[mid].score;
    if (score === midScore) { return mid; }
    else if (score > midScore) { hi = mid; }
    else { lo = mid + 1; }
  }
  return lo;
}

var Game = function(ctx) {
  this.ctx = ctx;
  this.ground = new Ground();
  this.gameLoopInterval = null;
  this.rafIntv = null;
  this.fpsts = this.fps = null;
  this.framebuf = ctx.createImageData(this.ground.w * this.ground.bs, this.ground.h * this.ground.bs);

  this.keysDown = new Set();
  this.unpaused = true;

  this.message = '';
  this.messageTimeout = null;
  this.messageOptions = {};
  this.infoText = '';
};

Game.prototype = {
  run() {
    this.startLevel();
    this.hookKeyboard();
    this.startPaintLoop();
    this.startGameLoop();
  },
  tick() {
    if (this.unpaused) {
      this.khandle();
      this.checkGameConditions();
      this.ground.moveEntities();
    }
  },
  startGameLoop() {
    this.gameLoopInterval = setInterval(this.tick.bind(this), 100);
  },
  stopGameLoop() {
    clearInterval(this.gameLoopInterval);
  },
  startLevel() {
    var g = this.ground;
    var rooms = genRooms(g);
    var numRooms = rooms.length;
    var room0 = rooms[0];
    var lastRoom = rooms[room0.farthest(rooms)];
    g.prot.placeAt(room0.cx, room0.cy);
    g.portal.placeAt(lastRoom.cx, lastRoom.cy);
    // Reset entities.
    for (var i = 0; i < g.tiles; i++) {
      g.entities[i] = [];
    }
    g.diggers = [];
    if (g.level > 0) {
      var numDiggers = (g.tiles / 1000) >>> 0;
      for (var i = 1; i < numDiggers && i < numRooms; i++) {
        g.diggers.push(new Digger(g, rooms[i].cx, rooms[i].cy));
      }
    }
    g.parasites = [];
    if (g.level > 1) {
      var numParasites = Math.max(2, (g.tiles / 2000) >>> 0);
      for (var i = 1; i < numParasites && i < numRooms; i++) {
        var room = rooms[numRooms - i];
        g.parasites.push(new Parasite(g, room.cx, room.cy));
      }
    }
    g.swarmers = [];
    if (g.level > 2) {
      var queenRoom = rooms[Math.floor(Math.random() * numRooms)];
      g.swarmers.push(new SwarmerQueen(g, room.cx, room.cy));
    }
    this.levelWelcome();
  },
  levelWelcome() {
    var g = this.ground;
    var msg;
    if (g.level === 0) {
      g.prot.life = Infinity;
      infoNode.style.display = 'none';
      msg = 'Level ' + g.level + ': Search.\n' +
        'Reach the orange square.\n' +
        'WASD/arrows to move, Space to pause.';
    } else if (g.level === 1) {
      g.prot.life = 2 * (g.w + g.h);
      infoNode.style.display = 'block';
      msg = 'Level ' + g.level + ': Life.\n' +
        'Your life is at ' + g.prot.life + '.\n' +
        'Eat purple diggers to survive.';
    } else if (g.level === 2) {
      msg = 'Level ' + g.level + ': Survival.\n' +
        'Your predator, the red parasites,\n' +
        'awaits you dearly.';
    } else if (g.level === 3) {
      msg = 'Level ' + g.level + ': Society.\n' +
        'Don’t hurt swarmers and you’ll be fine.';
    } else {
      msg = 'Level ' + g.level;
    }
    this.showMessage(msg, 5000, {dismissOnKeydown: true});
  },
  checkGameConditions() {
    var g = this.ground;
    if (g.prot.x === g.portal.x && g.prot.y === g.portal.y) {
      g.level++;
      this.startLevel();
    } else if (g.prot.life <= 0) {
      this.showMessage('404 Life Not Found');
    }
    for (var i = 0; i < g.entities.length; i++) {
      var entities = g.entities[i];
      if (entities.length >= 2) {
        for (var j = 0; j < entities.length; j++) {
          for (var k = 0; k < entities.length; k++) {
            if (j !== k) {
              entities[j].interact(entities[k]);
              if (entities[j] === undefined) {break;}
            }
          }
        }
      }
    }
    this.showInfoText('life ' + g.prot.life);
  },

  // Render
  startPaintLoop() {
    var game = this;
    game.rafIntv = requestAnimationFrame(function loop(timestamp) {
      game.fps = 1e3 / (timestamp - game.fpsts);
      game.fpsts = timestamp;
      game.paint();
      game.rafIntv = requestAnimationFrame(loop);
    });
  },
  stopPaintLoop() {
    cancelAnimationFrame(this.rafIntv);
  },
  paint() {
    var ctx = this.ctx, g = this.ground;
    var a = g.a, w = g.w, h = g.h, bs = g.bs;
    var l = a.length;
    var img = this.framebuf;
    var buf = img.data;
    // Rooms
    var i = 0;
    var j = 0;
    for (var k = 0; k < l; k++) {
      var b = a[k]; // block.
      if (b === 1) {
        var c = 64 + g.noise[k];
      } else {
        var c = g.noise[k];
      }
      this.paintBlock(buf, i, j, c, c, c, 255);
      i++;
      if (i >= w) {
        i = 0;
        j++;
      }
    }
    // Visibility
    var visible = g.vision(g.prot.x, g.prot.y, 5);
    for (var i = 0; i < visible.length; i++) {
      this.overpaintTile(buf, visible[i], 255, 255, 200, 25);
    }
    // Portal
    this.paintEntity(g.portal, buf);
    for (var i = 0; i < g.diggers.length; i++) {
      this.paintEntity(g.diggers[i], buf);
    }
    for (var i = 0; i < g.parasites.length; i++) {
      this.paintEntity(g.parasites[i], buf);
    }
    for (var i = 0; i < g.swarmers.length; i++) {
      this.paintEntity(g.swarmers[i], buf);
    }
    // Protagonist
    if (!g.prot.isDead()) {this.paintEntity(g.prot, buf);}
    ctx.putImageData(img, 0, 0);
  },
  paintEntity(entity, buf) {
    var color = entity.color;
    this.paintBlock(buf, entity.x, entity.y,
      color[0], color[1], color[2], color[3]);
  },
  paintTile(buf, tile, r, g, b, a) {
    var pos = this.ground.pos(tile);
    this.paintBlock(buf, pos[0], pos[1], r, g, b, a);
  },
  overpaintTile(buf, tile, r, g, b, a) {
    var pos = this.ground.pos(tile);
    this.overpaintBlock(buf, pos[0], pos[1], r, g, b, a);
  },
  paintBlock(buf, x, y, r, g, b, a) {
    var bs = this.ground.bs >>> 0, w = (this.ground.w*bs) >>> 0;
    var jmax = y*bs + bs, imax = x*bs + bs;
    // i, j: pixel position
    for (var j = y*bs; j < jmax; j++) {
      var jw = j*w;
      for (var i = x*bs; i < imax; i++) {
        var pi = (jw+i)*4;  // pixel index
        buf[pi + 0] = r;
        buf[pi + 1] = g;
        buf[pi + 2] = b;
        buf[pi + 3] = a;
      }
    }
  },
  overpaintBlock(buf, x, y, r, g, b, a) {
    var bs = this.ground.bs >>> 0, w = (this.ground.w*bs) >>> 0;
    var ao = (255 - a) >>> 0, an = a >>> 0;
    var jmax = y*bs + bs, imax = x*bs + bs;
    // i, j: pixel position
    for (var j = y*bs; j < jmax; j++) {
      var jw = j*w;
      for (var i = x*bs; i < imax; i++) {
        var pi = (jw+i)*4;  // pixel index
        buf[pi + 0] = ((ao * buf[pi + 0] + an * r) / 255) >>> 0;
        buf[pi + 1] = ((ao * buf[pi + 1] + an * g) / 255) >>> 0;
        buf[pi + 2] = ((ao * buf[pi + 2] + an * b) / 255) >>> 0;
        buf[pi + 3] = 255;
      }
    }
  },

  // Keyboard input
  khandle() {
    var g = this.ground;
    // WASD / arrows
    if (this.keysDown.has(38) || this.keysDown.has(87)) {
      g.prot.goUp(); }
    if (this.keysDown.has(39) || this.keysDown.has(68)) {
      g.prot.goRight(); }
    if (this.keysDown.has(40) || this.keysDown.has(83)) {
      g.prot.goDown(); }
    if (this.keysDown.has(37) || this.keysDown.has(65)) {
      g.prot.goLeft(); }
    if (this.keysDown.has(74)) { // J
      g.level++;
      this.startLevel();
    }
    if (this.keysDown.has(75)) { // K
      g.level--;
      this.startLevel();
    }
  },
  kdown(event) {
    if (this.unpaused) { this.keysDown.add(event.keyCode); }
    if (!event.repeat && this.messageOptions.dismissOnKeydown
        && this.messageTimeout === undefined) {
      this.messageOptions.dismissOnKeydown = false;
      this.hideMessage();
    }
  },
  kup(event) {
    if (event.keyCode === 32) { // space
      this.unpaused = !this.unpaused;
      if (this.unpaused) { this.hideMessage(); }
      else { this.showMessage('Paused'); }
    }
    this.keysDown.delete(event.keyCode);
  },
  hookKeyboard() {
    addEventListener('keydown', this.kdown.bind(this));
    addEventListener('keyup', this.kup.bind(this));
  },
  unhookKeyboard() {
    removeEventListener('keydown', this.kdown.bind(this));
    removeEventListener('keyup', this.kup.bind(this));
  },

  // Messages
  showMessage(msg, time, options) {
    this.messageOptions = options || {};
    if (msg !== this.message) {
      this.message = msg;
      msgNode.innerHTML = msg.replace(/\n/g, '<br>');
    }
    this.hideMessage();
    if (time !== undefined) {
      messageTimeout = setTimeout(this.hideMessage.bind(this), time);
    }
    msgNode.style.display = 'block';
  },
  hideMessage() {
    if (this.messageTimeout !== undefined) {
      clearTimeout(this.messageTimeout);
      this.messageTimeout = undefined;
    }
    if (this.messageOptions.dismissOnKeydown) { return; }
    msgNode.style.display = 'none';
  },
  showInfoText(text) {
    if (text !== this.infoText) {
      this.infoText = text;
      infoNode.textContent = text;
    }
  },
};

// Initialization
var game = new Game(ctx);
game.run();
</script>
